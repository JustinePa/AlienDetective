---
title: "Documentation AlienDetective.R"
author: "Matthijs Gielen"
date: "2025-06-02"
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

This document explains how the script `AlienDetective.R` works and how it should be used or customized.  

# Setup environment  

The script begins by configuring the working environment  

## Parallelisation setup  

The script defines the number of cores to use when running tasks in parallel (only on **Unix-based** systems). The value must be a positive integer.  

```{r}
num_cores <- 4

if (!is.numeric(num_cores) || num_cores <= 0 || num_cores != floor(num_cores)) {
  stop("Number of cores must be a positive, natural number!")
}
```

>**Note:** This parallel setup is tested only for **Unix-based systems**. If you are on Windows, it's recommended to comment out or remove this section as it may not function properly.  

## Set CRAN mirror  

To ensure package installation works on a server, the script sets a default CRAN mirror

```{r}
options(repos = c(CRAN = "https://cloud.r-project.org"))
```

You can replace the URL above with a local CRAN mirror if needed.  

## Install required packages  

This block ensures all required packages are installed (but not loaded, the use of explicit namespaces, e.g. `raster::extract()` are preferred).  

```{r}
cat(">>> [INIT] Checking for required packages...\n")
packages <- c("rgbif", "sf", "sp", "gdistance", "geodist", "raster", "fasterize", "ggplot2", "rnaturalearth", "rnaturalearthdata", "dplyr", "spThin", "foreach", "doParallel")
for (package in packages) {
  if(!requireNamespace(package, quietly = TRUE)) {
    install.packages(package)
  }
}
```

If an installation fails due to package incompatibility with your R version, try installing it from source:  

```{r}
install.packages(package, pkgType = "source")
```

## Load custom functions  

The script loads all custom helper functions from the file `funtions.R`.  

```{r}
source("Scripts/functions.R")
```

---  

# Input  

## Command-line arguments and defaults  

The script accepts command-line arguments to define input and output paths:  

| **Position** | **Description**                |
| ------------ | -------------------------------|
| 1            | Path to species CSV file       |
| 2            | Path to coordinates CSV file   |
| 3            | Path to rasterized world map * |
| 4            | Path to cost matrix *          |
| 5            | Path to output directory       |

>*: When these files don't exist, they will be generated by the script.  

The command-line arguments are read as follows: 

```{r}
cat(">>> [INIT] Reading input data...\n")
args <- commandArgs(trailingOnly = TRUE)
species_location_path <- args[1]
location_coordinates_path <- args[2]
rasterized_path <- args[3]
cost_matrix_path <- args[4]
output_dir <- args[5]
```

*Fallback to default paths*  
If the script is run without command-line arguments, it will use predefined local paths:  

```{r}
if (length(args) == 0) {
  species_location_path <- file.path("Input", "Species_Location_NIS.csv")
  location_coordinates_path <- file.path("Input", "Coordinates_NIS.csv")
  land_polygons_path <- file.path("Input/land_polygons", "land_polygons.shp")
  rasterized_path <- file.path("Input", "rasterized_land_polygons.rds")
  cost_matrix_path <- file.path("Input", "cost_matrix.rds")
  output_dir <- "Output"
}
```

## Reading input data  

### Species-location presence/absence matrix  

The script reads the presence/absence matrix from a csv file.  
If a species appears more than once, only the first occurrence is kept.  
It is possible to subselect a certain species or multiple species, if not needed, comment the lines out.  

```{r}
species_location <- read.csv(species_location_path, sep = ";")
species_location <- species_location[!duplicated(species_location[1]),]

# Subselect species
species_subset <- c("...") # Specify species to subselect here
species_location <- species_location[which(species_location$Specieslist %in% species_subset),]

```

### Location coordinates  

Load the coordinate data for each observation site (`ObservatoryID` in species-location csv) from the csv file.  

```{r}
location_coordinates <- read.csv(location_coordinates_path, sep = ";")
```

### Define GBIF fields  

Define the columns to retain from the downloaded GBIF occurrence data.  

```{r}
required_columns <- c("decimalLatitude", "decimalLongitude", "year", "month", "country")
```

# Map configuration  

The script uses 2 objects to define the world and the values of each cell:  

- `r`: A rasterized map of the world.  
- `cost_matrix`: A matrix that defines if a cell in land (`NA`) or sea (`1`).  

Both the objects can be saved in .rds files to avoid regenerating them every time the script is runned. When the files are not present in the specified location, the files will be generated and saved. The code below checks whether the files exist, if so they are loaded. If not, they are generated and saved.  

- Rasterized map of the world:  

```{r}
cat(">>> [MAP] Loading world map...\n")

if(file.exists(rasterized_path)) {
  r <- readRDS(rasterized_path)
} else {
  # Read vector map as sf object
  #land_polygons <- sf::st_read(land_polygons_path)
  land_polygons <- rnaturalearth::ne_countries(scale = "large", returnclass = "sf")
  cat(">>> [MAP] Rasterizing land polygons...\n")
  # Create raster
  r <- raster::raster(raster::extent(-180, 180, -90, 90), crs = sp::CRS("+init=EPSG:4326"), resolution = 0.1)
  # Rasterize vector map using fasterize
  r <- fasterize::fasterize(land_polygons, r, field = NULL, fun = "max")
  # Set sea cells to value 1 and land cells to NA (Opposite of what fasterize outputs)
  r <- raster::calc(r, function(x) ifelse(is.na(x), 1, NA))
  saveRDS(r, rasterized_path)
  rm(land_polygons)
  cat(">>> [MAP] Rasterization done. Saved raster to \"", file.path(getwd(), rasterized_path), "\"\n")
}
```

- Cost matrix:  

```{r}
if (file.exists(cost_matrix_path)) {
  cat(">>> [MAP] Loading cost matrix...\n")
  cost_matrix <- readRDS(cost_matrix_path)
} else {
  cat(">>> [MAP] Generating cost matrix...\n")
  # Create a transition object for adjacent cells
  cost_matrix <- gdistance::transition(r, transitionFunction = mean, directions = 16)
  # Set infinite costs to NA to prevent travel through these cells
  cost_matrix <- gdistance::geoCorrection(cost_matrix, type = "c", scl = FALSE)
  # Save transition matrix
  saveRDS(cost_matrix, file = cost_matrix_path)
  cat(">>> [MAP] Saved cost matrix to \"", file.path(getwd(), cost_matrix_path), "\"\n")
}
```


